<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            flex-direction: column;
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-weight: bold;
            font-size: 14px;
        }
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 100px;
        }
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-left: auto;
        }
        button:hover {
            background-color: #45a049;
        }
        .graph-container {
            position: relative;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }
        canvas {
            display: block;
            background-color: #fafafa;
        }
        .export-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Interactive Graph Editor</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="length">Length:</label>
                <input type="number" id="length" min="1" value="10" step="1">
            </div>
            <div class="control-group">
                <label for="samples">Samples:</label>
                <input type="number" id="samples" min="2" value="50" step="1">
            </div>
            <button id="export">Export CSV</button>
        </div>
        
        <div class="graph-container">
            <canvas id="graph" width="760" height="400"></canvas>
        </div>
        
        <div class="export-info">
            <p id="export-result"></p>
        </div>
    </div>

    <script>
        // DOM elements
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');
        const lengthInput = document.getElementById('length');
        const samplesInput = document.getElementById('samples');
        const exportButton = document.getElementById('export');
        const exportResult = document.getElementById('export-result');
        
        // Graph configuration
        const GRAPH_WIDTH = canvas.width;
        const GRAPH_HEIGHT = canvas.height;
        const PADDING = 40;
        const GRAPH_INNER_WIDTH = GRAPH_WIDTH - 2 * PADDING;
        const GRAPH_INNER_HEIGHT = GRAPH_HEIGHT - 2 * PADDING;
        const POINT_RADIUS = 5;
        
        // Graph state
        let points = [];
        let length = parseInt(lengthInput.value);
        let samples = parseInt(samplesInput.value);
        let isDragging = false;
        let dragPointIndex = -1;
        
        // Initialize the graph with a default line at y=0.1
        function initializeGraph() {
            points = [
                { x: 0, y: 0.1 },
                { x: length, y: 0.1 }
            ];
            drawGraph();
        }
        
        // Convert graph coordinates to canvas coordinates
        function graphToCanvas(x, y) {
            return {
                x: PADDING + (x / length) * GRAPH_INNER_WIDTH,
                y: PADDING + GRAPH_INNER_HEIGHT - (y / 3) * GRAPH_INNER_HEIGHT
            };
        }
        
        // Convert canvas coordinates to graph coordinates
        function canvasToGraph(x, y) {
            return {
                x: ((x - PADDING) / GRAPH_INNER_WIDTH) * length,
                y: 3 * (1 - (y - PADDING) / GRAPH_INNER_HEIGHT)
            };
        }
        
        // Draw the graph
        function drawGraph() {
            // Clear canvas
            ctx.clearRect(0, 0, GRAPH_WIDTH, GRAPH_HEIGHT);
            
            // Draw grid and axes
            drawGrid();
            
            // Draw the line
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#2196F3';
            
            for (let i = 0; i < points.length; i++) {
                const canvasPoint = graphToCanvas(points[i].x, points[i].y);
                
                if (i === 0) {
                    ctx.moveTo(canvasPoint.x, canvasPoint.y);
                } else {
                    ctx.lineTo(canvasPoint.x, canvasPoint.y);
                }
            }
            
            ctx.stroke();
            
            // Draw points
            for (let i = 0; i < points.length; i++) {
                const canvasPoint = graphToCanvas(points[i].x, points[i].y);
                
                ctx.beginPath();
                ctx.arc(canvasPoint.x, canvasPoint.y, POINT_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = '#FF5722';
                ctx.fill();
                ctx.strokeStyle = '#E64A19';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        
        // Draw grid and axes
        function drawGrid() {
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            
            // Draw vertical grid lines
            for (let x = 0; x <= length; x++) {
                const canvasX = PADDING + (x / length) * GRAPH_INNER_WIDTH;
                
                ctx.beginPath();
                ctx.moveTo(canvasX, PADDING);
                ctx.lineTo(canvasX, PADDING + GRAPH_INNER_HEIGHT);
                ctx.stroke();
                
                // X axis labels
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(x, canvasX, PADDING + GRAPH_INNER_HEIGHT + 20);
            }
            
            // Draw horizontal grid lines
            for (let y = 0; y <= 3; y += 0.5) {
                const canvasY = PADDING + GRAPH_INNER_HEIGHT - (y / 3) * GRAPH_INNER_HEIGHT;
                
                ctx.beginPath();
                ctx.moveTo(PADDING, canvasY);
                ctx.lineTo(PADDING + GRAPH_INNER_WIDTH, canvasY);
                ctx.stroke();
                
                // Y axis labels
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(y.toFixed(1), PADDING - 10, canvasY + 4);
            }
            
            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            // X axis
            ctx.beginPath();
            ctx.moveTo(PADDING, PADDING + GRAPH_INNER_HEIGHT);
            ctx.lineTo(PADDING + GRAPH_INNER_WIDTH, PADDING + GRAPH_INNER_HEIGHT);
            ctx.stroke();
            
            // Y axis
            ctx.beginPath();
            ctx.moveTo(PADDING, PADDING);
            ctx.lineTo(PADDING, PADDING + GRAPH_INNER_HEIGHT);
            ctx.stroke();
        }
        
        // Find the closest point to the click position
        function findClosestPoint(x, y) {
            const graphCoords = canvasToGraph(x, y);
            let minDist = Infinity;
            let closestIndex = -1;
            
            for (let i = 0; i < points.length; i++) {
                const dx = points[i].x - graphCoords.x;
                const dy = points[i].y - graphCoords.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < minDist) {
                    minDist = dist;
                    closestIndex = i;
                }
            }
            
            // Check if the click is close enough to a point
            const canvasPoint = graphToCanvas(points[closestIndex].x, points[closestIndex].y);
            const dx = x - canvasPoint.x;
            const dy = y - canvasPoint.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            return dist <= POINT_RADIUS * 2 ? closestIndex : -1;
        }
        
        // Add a new point to the graph
        function addPoint(x, y) {
            const graphCoords = canvasToGraph(x, y);
            
            // Find where to insert the new point
            let insertIndex = 0;
            for (let i = 0; i < points.length; i++) {
                if (graphCoords.x > points[i].x) {
                    insertIndex = i + 1;
                }
            }
            
            // Add the new point
            points.splice(insertIndex, 0, {
                x: Math.max(0, Math.min(length, graphCoords.x)),
                y: Math.max(0, Math.min(3, graphCoords.y))
            });
            
            drawGraph();
        }
        
        // Export data as CSV
        function exportCSV() {
            const step = length / (samples - 1);
            let csvData = [];
            
            // Generate the data points
            for (let i = 0; i < samples; i++) {
                const x = i * step;
                let y = 0;
                
                // Find the segment that contains this x value
                for (let j = 0; j < points.length - 1; j++) {
                    if (x >= points[j].x && x <= points[j + 1].x) {
                        // Linear interpolation
                        const t = (x - points[j].x) / (points[j + 1].x - points[j].x);
                        y = points[j].y + t * (points[j + 1].y - points[j].y);
                        break;
                    }
                }
                
                csvData.push(y.toFixed(4));
            }
            
            // Create CSV content
            const csvContent = csvData.join(',');
            
            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'masa.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Show export confirmation
            exportResult.textContent = `Exported ${samples} samples. CSV file downloaded.`;
        }
        
        // Event handlers
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on an existing point
            const pointIndex = findClosestPoint(x, y);
            
            if (pointIndex !== -1) {
                // Start dragging the point
                isDragging = true;
                dragPointIndex = pointIndex;
            } else {
                // Add a new point
                addPoint(x, y);
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const graphCoords = canvasToGraph(x, y);
                
                // Update the point position with constraints
                points[dragPointIndex].x = Math.max(0, Math.min(length, graphCoords.x));
                
                // Ensure the point stays within the x bounds of its neighbors
                if (dragPointIndex > 0) {
                    points[dragPointIndex].x = Math.max(points[dragPointIndex - 1].x, points[dragPointIndex].x);
                }
                if (dragPointIndex < points.length - 1) {
                    points[dragPointIndex].x = Math.min(points[dragPointIndex + 1].x, points[dragPointIndex].x);
                }
                
                points[dragPointIndex].y = Math.max(0, Math.min(3, graphCoords.y));
                
                drawGraph();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            dragPointIndex = -1;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            dragPointIndex = -1;
        });
        
        lengthInput.addEventListener('change', () => {
            const newLength = parseInt(lengthInput.value);
            
            if (newLength > 0) {
                // Scale existing points to new length
                const scale = newLength / length;
                for (let i = 0; i < points.length; i++) {
                    points[i].x *= scale;
                }
                
                length = newLength;
                drawGraph();
            } else {
                lengthInput.value = length;
            }
        });
        
        samplesInput.addEventListener('change', () => {
            const newSamples = parseInt(samplesInput.value);
            
            if (newSamples >= 2) {
                samples = newSamples;
            } else {
                samplesInput.value = samples;
            }
        });
        
        exportButton.addEventListener('click', exportCSV);
        
        // Initialize the graph
        initializeGraph();
    </script>
</body>
</html>
